<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Solar Farm Collector Designer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet"/>
  <style>
    body { font-family:'Inter',sans-serif; background:#f0f8ff; margin:0 }
    main { padding:20px; max-width:1800px; margin:auto }
    label { display:block; margin:10px 0 4px; font-weight:600 }
    input, textarea { width:300px; padding:8px; margin-bottom:10px; border:1px solid #ccc; border-radius:6px }
    button { margin:10px 10px 0 0; padding:10px 16px; background:#0a66c2; color:#fff; border:none; border-radius:6px; cursor:pointer }
    button:hover { background:#004a99 }
    #canvasContainer { width:100%; height:65vh; min-height:500px; border:1px solid #ccc; overflow:hidden; position:relative; cursor:grab; background:#fafdff }
    #canvasContainer.grabbing { cursor:grabbing }
    canvas { transform-origin:0 0; display:block }
    #coordContainer { display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:10px; margin-top:10px }
    .coordPane { background:#fff; border:1px solid #ccc; padding:10px; font-family:monospace; white-space:pre; max-height:300px; overflow:auto; font-size:13px }
  </style>
</head>
<body>
<main>
  <h1>âš¡ Solar Farm Collector Designer</h1>
  <!-- Input Controls -->
  <label>Total Inverters</label><input type="number" id="total" placeholder="e.g., 40">
  <label>Default Inverters per Feeder</label><input type="number" id="perFeeder" placeholder="e.g., 8">
  <label>Custom Feeder Configuration</label><textarea id="customFeeder" placeholder="e.g., 4,4,4,4"></textarea>
  <label>Capacitor Bank (kVAR)</label><input type="number" id="capacitor" placeholder="e.g., 500">
  <label>MV Voltage (kV)</label><input type="number" id="mvVoltage" value="34.5" step="0.1">
  <label>LV Voltage (kV)</label><input type="number" id="lvVoltage" value="0.66" step="0.01">
  <label>Impedance (Z pu)</label><input type="number" id="impedance" placeholder="e.g., 0.03" step="0.01">
  <div><input type="checkbox" id="lvLoad"><label for="lvLoad">Add Load on LV side</label></div>
  <div><input type="checkbox" id="showLegend" checked><label for="showLegend">Show Legend</label></div>
  <div><input type="checkbox" id="showCoords"><label for="showCoords">Show Bus Coordinates</label></div>
  <button id="genBtn">Generate</button>
  <button id="resetBtn">Reset View</button>
  <button id="zoomInBtn">Zoom In</button>
  <button id="zoomOutBtn">Zoom Out</button>
  <label for="zoomSlider">Zoom:</label><input type="range" id="zoomSlider" min="0.1" max="3" step="0.01" value="1">
  <button id="downloadLocBtn">Download .loc</button>
  <button id="downloadIdvBtn">bus.idv</button>
  <button id="downloadBranchIdvBtn">branch.idv</button>
  <div id="canvasContainer"><canvas id="schematicCanvas" width="1800" height="2000"></canvas></div>
  <div id="coordContainer">
    <div id="leftPane" class="coordPane">Bus coords appear here.</div>
    <div id="locPane" class="coordPane">.loc output appears here.</div>
    <div id="idvPane" class="coordPane">bus.idv output appears here.</div>
    <div id="branchIdvPane" class="coordPane">branch.idv output appears here.</div>
  </div>
</main>
<script>
(() => {
  const canvas = document.getElementById('schematicCanvas'),
        ctx    = canvas.getContext('2d'),
        container = document.getElementById('canvasContainer'),
        slider = document.getElementById('zoomSlider');

  let scale=1, panX=0, panY=0, isPanning=false, startX=0, startY=0;
  let parsedLayout = [], busCoords = [], branches = [], mvPoints = [];
  let mvKV=34.5, lvKV=0.66;

  // Pan / Zoom Functions
  function updateTransform(){ canvas.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`; }
  function resetView(){ scale=1; panX=0; panY=0; updateTransform(); slider.value=scale; }
  function zoomTo(ns,cx=canvas.clientWidth/2,cy=canvas.clientHeight/2){
    panX -= (cx/scale - cx/ns);
    panY -= (cy/scale - cy/ns);
    scale = ns; updateTransform(); slider.value = ns;
  }
  slider.addEventListener('input', e => zoomTo(+e.target.value));
  document.getElementById('resetBtn').addEventListener('click', resetView);
  document.getElementById('zoomInBtn').addEventListener('click', ()=>zoomTo(Math.min(scale*1.1,3)));
  document.getElementById('zoomOutBtn').addEventListener('click', ()=>zoomTo(Math.max(scale*0.9,0.1)));
  container.addEventListener('wheel', e => {
    e.preventDefault();
    const d = -e.deltaY * 0.001;
    const ns = Math.min(Math.max(scale + d, 0.1), 3);
    const r  = canvas.getBoundingClientRect();
    zoomTo(ns, e.clientX - r.left, e.clientY - r.top);
  });
  container.addEventListener('mousedown', e => {
    isPanning = true; container.classList.add('grabbing');
    startX = e.clientX - panX; startY = e.clientY - panY;
  });
  document.addEventListener('mousemove', e => {
    if(!isPanning) return;
    panX = e.clientX - startX; panY = e.clientY - startY; updateTransform();
  });
  document.addEventListener('mouseup', () => {
    isPanning = false; container.classList.remove('grabbing');
  });

  // Generate diagram
  document.getElementById('genBtn').addEventListener('click', () => {
    try {
      const total = +document.getElementById('total').value;
      if(!total){ alert('Enter total inverters'); return; }
      const perF = +document.getElementById('perFeeder').value,
            custom = document.getElementById('customFeeder').value.trim();
      mvKV = +document.getElementById('mvVoltage').value;
      lvKV = +document.getElementById('lvVoltage').value;

      // Build feeder config robustly
      let feederConfig = [], rem = total;
      if(custom){
        const arr = custom.split(',').map(n=>parseInt(n,10));
        if(arr.some(isNaN)) { alert('Invalid custom feeder input'); return; }
        feederConfig = arr.filter(n=>n>0);
        let sum = feederConfig.reduce((a,b)=>a+b,0);
        while(sum < total){ feederConfig.push(1); sum++; }
        if(sum > total){
          let run=0;
          feederConfig = feederConfig.filter(n => {
            if(run+n <= total){ run+=n; return true; }
            if(run < total){ feederConfig.push(total-run); run=total; return true; }
            return false;
          });
        }
      } else {
        while(rem>0){
          const cnt = Math.min(perF>0?perF:total, rem);
          feederConfig.push(cnt); rem -= cnt;
        }
      }

      // Flatten layout
      parsedLayout = [];
      feederConfig.forEach((cnt,i) => { for(let j=0;j<cnt;j++){ parsedLayout.push({ feeder: i+1 }); }});

      drawLayout(feederConfig);
      fitToContainer();
      updatePanes();
    } catch(err) {
      console.error(err);
      alert('Error generating layout: ' + err.message);
    }
  });

  function drawLayout(feederConfig){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    busCoords=[]; mvPoints=[];

    // Fixed positions
    const cx = 900, POI_Y=100, GSU_Y=180, XFMR_Y=230, SUBMV_Y=340;
    const sx = 180, sy = 100, nF = feederConfig.length;

    // (Existing drawing of generator, buses, transformer omitted for brevity...)

    // SUB-MV BUS
    const subW = (nF-1)*sx + 100;
    ctx.save(); ctx.strokeStyle='#0a66c2'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(cx-subW/2, SUBMV_Y); ctx.lineTo(cx+subW/2, SUBMV_Y); ctx.stroke();
    ctx.font='bold 13px Inter'; ctx.fillStyle='#0a66c2';
    ctx.fillText('SUB-MV BUS', cx+subW/2+10, SUBMV_Y+5);
    ctx.restore();
    busCoords.push({ name:'SUB-MV BUS', x:cx, y:SUBMV_Y });

    // Place MV point positions
    let idx=0;
    feederConfig.forEach((cnt, fi) => {
      const baseX = cx - ((nF-1)/2)*sx + fi*sx;
      for(let j=0;j<cnt;j++){
        const y = SUBMV_Y + 40 + j*sy;
        mvPoints.push({ x: baseX, y, name:`INV${1001+idx}`, feeder:fi+1 }); idx++;
      }
    });

    // Draw MV feeder cables
    const feederGroups = mvPoints.reduce((acc, pt) => {
      acc[pt.feeder] = acc[pt.feeder]||[]; acc[pt.feeder].push(pt); return acc;
    }, {});
    ctx.save(); ctx.strokeStyle='#888'; ctx.lineWidth=2;
    Object.values(feederGroups).forEach(group => {
      if(group.length){
        const first = group[0];
        ctx.beginPath(); ctx.moveTo(first.x, SUBMV_Y); ctx.lineTo(first.x, first.y); ctx.stroke();
        for(let i=1;i<group.length;i++){
          const prev = group[i-1], curr = group[i];
          ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(curr.x, curr.y); ctx.stroke();
        }
      }
    });
    ctx.restore();

    // Draw MV nodes, PAD and LV with vertical connectors
    mvPoints.forEach(pt => { /* existing node drawing code */ });
  }

  /* fitToContainer, updatePanes, download handlers unchanged */

})();
</script>
</body>
</html>
