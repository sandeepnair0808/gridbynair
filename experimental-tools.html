<script>
  // ─── Shared state ─────────────────────────────
  let parsedLayout = [], poiOrigin = {x:0,y:0}, busCoords = [];

  const container = document.getElementById('canvasContainer'),
        canvas    = document.getElementById('schematicCanvas'),
        ctx       = canvas.getContext('2d'),
        slider    = document.getElementById('zoomSlider');

  let scale=1, panX=0, panY=0,
      isPanning=false, startX=0, startY=0;

  // ─── Pan/Zoom Helpers ──────────────────────────
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px,${panY}px) scale(${scale})`;
  }
  function resetView() {
    scale=1; panX=0; panY=0;
    updateTransform(); slider.value=scale;
  }
  function zoomTo(ns, cx=canvas.clientWidth/2, cy=canvas.clientHeight/2) {
    panX -= (cx/scale - cx/ns);
    panY -= (cy/scale - cy/ns);
    scale = ns; updateTransform(); slider.value=ns;
  }
  slider.addEventListener('input', e => zoomTo(+e.target.value));
  container.addEventListener('wheel', e => {
    e.preventDefault();
    const d = -e.deltaY*0.001,
          ns = Math.min(Math.max(scale + d, 0.1), 10),
          r  = canvas.getBoundingClientRect();
    zoomTo(ns, e.clientX - r.left, e.clientY - r.top);
  });
  container.addEventListener('mousedown', e => {
    isPanning = true; container.classList.add('grabbing');
    startX = e.clientX - panX; startY = e.clientY - panY;
  });
  document.addEventListener('mousemove', e => {
    if (!isPanning) return;
    panX = e.clientX - startX; panY = e.clientY - startY;
    updateTransform();
  });
  document.addEventListener('mouseup', () => {
    isPanning = false; container.classList.remove('grabbing');
  });

  // ─── Generate + Draw ──────────────────────────
  function generateCollector() {
    // read inputs...
    const total     = +document.getElementById('total').value;
    if (!total) return alert('Enter total inverters');
    const perFeeder = +document.getElementById('perFeeder').value,
          custom    = document.getElementById('customFeeder').value.trim(),
          capacitor = +document.getElementById('capacitor').value,
          voltage   = +document.getElementById('voltage').value,
          impedance = +document.getElementById('impedance').value,
          lvLoad    = document.getElementById('lvLoad').checked;

    // build feederConfig array...
    let feederConfig = [], rem = total;
    if (custom) {
      feederConfig = custom.split(',').map(n=>+n).filter(n=>n>0);
      let sum = feederConfig.reduce((a,b)=>a+b,0);
      if (sum < total) while(sum++ < total) feederConfig.push(1);
      else if (sum > total) {
        let run = 0;
        feederConfig = feederConfig.filter(n => {
          if (run + n <= total) { run += n; return true; }
          if (run < total)       { feederConfig.push(total - run); run = total; return true; }
          return false;
        });
      }
    } else {
      while(rem>0){
        const cnt = Math.min(perFeeder || total, rem);
        feederConfig.push(cnt);
        rem -= cnt;
      }
    }

    // build parsedLayout
    parsedLayout = [];
    feederConfig.forEach((cnt,i)=>{
      for(let j=0;j<cnt;j++){
        parsedLayout.push({ feeder: i+1, inverter: parsedLayout.length+1,
                            capacitor, voltage, impedance, hasLoad: lvLoad });
      }
    });

    drawLayout(feederConfig);
    fitToContainer();
  }

  function drawLayout(feederConfig) {
    // clear + reset transform
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    updateTransform();
    busCoords = [];

    // constants
    const startX = 100,
          poiY   = 100,
          gsuY   = poiY + 80,
          mvY    = gsuY + 80,
          sx     = 180,
          sy     = 100,
          bLen   = 50,
          poiLen = 200,
          midX   = startX + feederConfig.length * sx / 2,
          poiStart = midX - poiLen/2,
          poiEnd   = midX + poiLen/2;
    poiOrigin = {x:midX, y:poiY};

    const line = (x1,y1,x2,y2,c,w=2) => {
      ctx.save();
      ctx.strokeStyle = c; ctx.lineWidth = w;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    };

    // 1) POI BUS
    line(poiStart, poiY, poiEnd, poiY, '#000', 3);
    ctx.save(); ctx.fillStyle='#000'; ctx.font='12px Inter';
      ctx.fillText('POI BUS', poiStart, poiY-10);
    ctx.restore();
    busCoords.push({
      name:'POI BUS',
      x: poiStart - poiOrigin.x + poiLen/2,
      y: 0,
      padWidth: poiLen/2,
      padHeight: 0
    });

    // 2) Generator + T-Line
    ctx.save();
      ctx.beginPath(); ctx.arc(midX, poiY-30, 10,0,2*Math.PI); ctx.stroke();
      ctx.fillText('Generator', midX-30, poiY-45);
    ctx.restore();
    line(midX, poiY-20, midX, poiY, '#000');
    line(midX, poiY,     midX, gsuY, '#000');
    ctx.save(); ctx.fillText('T-Line', midX+10, (poiY+gsuY)/2); ctx.restore();

    // 3) GSU HV BUS
    line(poiStart, gsuY, poiEnd, gsuY, '#0a66c2', 4);
    ctx.save(); ctx.fillText('GSU HV BUS', poiStart, gsuY-10); ctx.restore();
    busCoords.push({
      name:'GSU HV BUS',
      x: poiStart - poiOrigin.x + poiLen/2,
      y: gsuY - poiOrigin.y,
      padWidth: poiLen/2,
      padHeight: 20
    });

    // transformer body
    const xfH = 40, xfT = (gsuY+mvY)/2 - xfH/2;
    line(midX, gsuY,     midX, xfT,    '#2ecc71', 2);
    ctx.save(); ctx.fillStyle='#2ecc71';
      ctx.fillRect(midX-10, xfT, 20, xfH);
    ctx.restore();
    line(midX, xfT+xfH, midX, mvY, '#2ecc71', 2);

    // 4) SUB-MV BUS
    const subW = feederConfig.length * sx;
    line(startX, mvY, startX+subW, mvY, '#0a66c2', 4);
    ctx.save(); ctx.fillText('SUB-MV BUS', startX, mvY-10); ctx.restore();
    busCoords.push({
      name:'SUB-MV BUS',
      x: startX - poiOrigin.x + subW/2,
      y: mvY - poiOrigin.y,
      padWidth: subW/2,
      padHeight: 0
    });

    // 5) Feeders & Inverters
    let invCount = 0, fx = startX + 40;
    feederConfig.forEach((cnt, fi) => {
      const bottomY = mvY + cnt * sy;
      line(fx, mvY, fx, bottomY, '#444', 2);

      for (let j = 0; j < cnt; j++) {
        const y = mvY + (j+1)*sy,
              invName = `INV${1001 + invCount}`;

        // MV node
        line(fx, y, fx+bLen, y, '#0a66c2',2);
        ctx.save(); ctx.fillStyle='red';
          ctx.beginPath(); ctx.arc(fx, y, 4,0,2*Math.PI); ctx.fill();
          ctx.fillText(invName, fx-55, y-10);
        ctx.restore();
        busCoords.push({
          name: invName,
          x: fx - poiOrigin.x,
          y: y - poiOrigin.y,
          padWidth: bLen+12,
          padHeight: sy/2
        });

        // padmount
        ctx.save(); ctx.fillStyle='#2ecc71';
          ctx.fillRect(fx+bLen, y-10, 20,20);
        ctx.restore();

        // LV node + inverter box
        const tX = fx + bLen + 10,
              tT = y + 10, tB = y + 40, tM = (tT+tB)/2;
        line(tX, tT, tX, tB, '#ff9900', 2);
        ctx.save(); ctx.fillStyle='blue';
          ctx.beginPath(); ctx.arc(tX, tM, 4,0,2*Math.PI); ctx.fill();
          ctx.fillText(`${invName}_LV`, tX+10, tM+10);
        ctx.restore();
        busCoords.push({
          name: `${invName}_LV`,
          x: tX - poiOrigin.x,
          y: tM - poiOrigin.y,
          padWidth: 12,
          padHeight: 12
        });

        // box & label
        ctx.save(); ctx.fillStyle='#ffcc00';
          ctx.fillRect(fx+bLen-2, tB, 24,24);
        ctx.restore();
        ctx.save(); ctx.fillStyle='#000';
          ctx.fillText(`I${invCount+1}`, fx+bLen-5, tB+35);
        ctx.restore();

        // optional load dot
        if (parsedLayout[invCount].hasLoad) {
          ctx.save(); ctx.fillStyle='#ff4444';
            ctx.beginPath(); ctx.arc(tX+20, tB+12, 5,0,2*Math.PI); ctx.fill();
          ctx.restore();
        }

        invCount++;
      }

      // feeder label (e.g. “15B”)
      const base = 11 + Math.floor(fi/2),
            suf  = fi%2 ? 'B' : 'A',
            flbl = `${base}${suf}`;
      ctx.save(); ctx.fillText(flbl, fx-10, bottomY+30); ctx.restore();

      // include label in bounds
      busCoords.push({
        name: flbl,
        x: fx - poiOrigin.x,
        y: bottomY + 30 - poiOrigin.y,
        padWidth: 0,
        padHeight: 0
      });

      fx += sx;
    });

    // 6) Legend
    if (document.getElementById('showLegend').checked) {
      const LX=1400, LY=100;
      [['Red Dot','MV Bus Point'],['Green Box','Transformer'],['Blue Dot','LV Bus Point'],
       ['Yellow Box','Inverter'],['Red Circle','LV Load']]
      .forEach(([shape,txt],i)=>{
        const y = LY + 20 + i*20,
              clr = shape.includes('Red')   ? 'red'
                  : shape.includes('Green') ? '#2ecc71'
                  : shape.includes('Blue')  ? 'blue'
                  :                          '#ffcc00';
        ctx.save(); ctx.fillStyle=clr;
          if (shape.includes('Dot')) {
            ctx.beginPath(); ctx.arc(LX+10,y-4,5,0,2*Math.PI); ctx.fill();
          } else {
            ctx.fillRect(LX+3,y-10,14,14);
          }
        ctx.restore();
        ctx.save(); ctx.fillStyle='#000';
          ctx.fillText(txt, LX+25, y);
        ctx.restore();
      });
    }

    // 7) Coordinates Pane
    const pane = document.getElementById('coordPane');
    if (document.getElementById('showCoords').checked) {
      pane.textContent = busCoords
        .map(b=>`${b.name.padEnd(12)} (${b.x.toFixed(0).padStart(4)}, ${b.y.toFixed(0).padStart(4)})`)
        .join('\n');
    } else {
      pane.textContent = 'Bus coordinates will appear here when you check “Show Bus Coordinates” and hit Generate.';
    }
  }

  // ─── Uniform fitToContainer (both axes) ─────────────────────────
  function fitToContainer(margin=20) {
    if (!busCoords.length) return;

    // build footprint arrays
    const allX = [], allY = [];
    busCoords.forEach(p=>{
      const ax = p.x + poiOrigin.x,
            ay = p.y + poiOrigin.y;
      allX.push(ax - p.padWidth, ax + p.padWidth);
      allY.push(ay - p.padHeight, ay + p.padHeight);
    });

    const minX = Math.min(...allX), maxX = Math.max(...allX),
          minY = Math.min(...allY), maxY = Math.max(...allY),
          contentW = (maxX - minX) + margin*2,
          contentH = (maxY - minY) + margin*2,
          CW = container.clientWidth,
          CH = container.clientHeight,

          uScale = Math.min(CW/contentW, CH/contentH),

          offX = (CW - contentW*uScale)/2 - (minX - margin)*uScale,
          offY = (CH - contentH*uScale)/2 - (minY - margin)*uScale;

    // apply
    scale = uScale; panX = offX; panY = offY;
    canvas.style.transform = `translate(${offX}px,${offY}px) scale(${uScale})`;
    slider.value = uScale;
  }

  // ─── Auto–rescale on resize ─────────────────────────────────────
  window.addEventListener('resize', fitToContainer);
  if ('ResizeObserver' in window) {
    new ResizeObserver(fitToContainer).observe(container);
  }

  // ─── Export helpers ─────────────────────────────────────────────
  window.exportSVG = ()=>{
    const a=document.createElement('a');
    a.download='schematic.svg';
    a.href=canvas.toDataURL('image/svg+xml');
    a.click();
  };
  window.exportPDF = ()=>{
    const { jsPDF } = window.jspdf;
    const pdf=new jsPDF({orientation:'landscape',unit:'pt',format:[canvas.width,canvas.height]});
    pdf.addImage(canvas.toDataURL('image/png'),'PNG',0,0,canvas.width,canvas.height);
    pdf.save('schematic.pdf');
  };
  window.exportDXF = ()=>alert('DXF not implemented');
</script>
