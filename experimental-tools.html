<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Farm Collector Designer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { font-family:'Inter',sans-serif; background:#f0f8ff; margin:0; }
    main { padding:20px; max-width:1800px; margin:auto; }
    label { display:block; margin:10px 0 4px; font-weight:600; }
    input, textarea {
      width:300px; padding:8px; margin-bottom:10px;
      border:1px solid #ccc; border-radius:6px;
    }
    button {
      margin:10px 10px 0 0; padding:10px 16px;
      background:#0a66c2; color:#fff; border:none;
      border-radius:6px; cursor:pointer;
    }
    button:hover { background:#004a99; }
    #canvasContainer {
      width: 100%; height: 600px;
      border:1px solid #ccc;
      overflow: hidden;
      position: relative;
      cursor: grab;
    }
    #canvasContainer.grabbing { cursor: grabbing; }
    canvas { transform-origin: 0 0; display: block; }
    #coordPane {
      margin-top:10px; padding:10px;
      background:#fff; border:1px solid #ccc;
      font-family:monospace; white-space:pre;
      max-height:300px; overflow:auto;
    }
  </style>
</head>
<body>
<main>
  <h1>⚡ Solar Farm Collector Designer</h1>

  <label>Total Inverters</label>
  <input type="number" id="total" placeholder="e.g., 40" />

  <label>Default Inverters per Feeder</label>
  <input type="number" id="perFeeder" placeholder="e.g., 8" />

  <label>Custom Feeder Configuration</label>
  <textarea id="customFeeder" placeholder="e.g., 4,4,4,4"></textarea>

  <label>Capacitor Bank (kVAR)</label>
  <input type="number" id="capacitor" placeholder="e.g., 500" />

  <label>Voltage (kV)</label>
  <input type="number" id="voltage" placeholder="e.g., 33" />

  <label>Impedance (Z pu)</label>
  <input type="number" id="impedance" placeholder="e.g., 0.03" step="0.01"/>

  <div>
    <input type="checkbox" id="lvLoad"/>
    <label for="lvLoad">Add Load on LV side</label>
  </div>
  <div>
    <input type="checkbox" id="showLegend" checked/>
    <label for="showLegend">Show Legend</label>
  </div>
  <div>
    <input type="checkbox" id="showCoords"/>
    <label for="showCoords">Show Bus Coordinates</label>
  </div>

  <button onclick="generateCollector()">Generate</button>
  <button onclick="resetView()">Reset View</button>
  <button onclick="zoomIn()">Zoom In</button>
  <button onclick="zoomOut()">Zoom Out</button>
  <label for="zoomSlider">Zoom:</label>
  <input type="range" id="zoomSlider" min="0.1" max="10" step="0.1" value="1" />
  <button onclick="exportSVG()">Export SVG</button>
  <button onclick="exportPDF()">Export PDF</button>
  <button onclick="exportDXF()">Export DXF</button>

  <div id="canvasContainer">
    <canvas id="schematicCanvas" width="1800" height="2400"></canvas>
  </div>
  <div id="coordPane">
    Bus coordinates will appear here when you check “Show Bus Coordinates” and hit Generate.
  </div>
</main>

<script>
  let parsedLayout = [],
      poiOrigin    = { x:0, y:0 },
      busCoords    = [];

  const container = document.getElementById('canvasContainer'),
        canvas    = document.getElementById('schematicCanvas'),
        ctx       = canvas.getContext('2d'),
        slider    = document.getElementById('zoomSlider');

  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX = 0, startY = 0;

  // ─── pan/zoom helpers ───────────────────────────────────────────────

  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }
  function resetView() {
    scale = 1; panX = panY = 0;
    updateTransform();
    slider.value = scale;
  }
  function zoomTo(newScale, cx = canvas.clientWidth/2, cy = canvas.clientHeight/2) {
    panX -= (cx/scale - cx/newScale);
    panY -= (cy/scale - cy/newScale);
    scale = newScale;
    updateTransform();
    slider.value = scale;
  }
  function zoomIn()  { zoomTo(Math.min(scale * 1.1, 10)); }
  function zoomOut() { zoomTo(Math.max(scale * 0.9, 0.1)); }
  slider.addEventListener('input', e => zoomTo(parseFloat(e.target.value)));

  container.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = -e.deltaY * 0.001;
    const newScale = Math.min(Math.max(scale + delta, 0.1), 10);
    const rect = canvas.getBoundingClientRect();
    zoomTo(newScale, e.clientX - rect.left, e.clientY - rect.top);
  });
  container.addEventListener('mousedown', e => {
    isPanning = true; container.classList.add('grabbing');
    startX = e.clientX - panX; startY = e.clientY - panY;
  });
  document.addEventListener('mousemove', e => {
    if (!isPanning) return;
    panX = e.clientX - startX; panY = e.clientY - startY;
    updateTransform();
  });
  document.addEventListener('mouseup', () => {
    isPanning = false; container.classList.remove('grabbing');
  });

  // ─── main generation ────────────────────────────────────────────────

  function generateCollector() {
    const total      = parseInt(document.getElementById('total').value);
    if (!total || total <= 0) return alert('Enter total inverters');
    const perFeeder  = parseInt(document.getElementById('perFeeder').value);
    const custom     = document.getElementById('customFeeder').value.trim();
    const capacitor  = parseInt(document.getElementById('capacitor').value);
    const voltage    = parseFloat(document.getElementById('voltage').value);
    const impedance  = parseFloat(document.getElementById('impedance').value);
    const lvLoad     = document.getElementById('lvLoad').checked;

    // build feederConfig…
    let feederConfig = [], remaining = total;
    if (custom) {
      feederConfig = custom.split(',').map(n=>parseInt(n)).filter(n=>!isNaN(n));
      let sum = feederConfig.reduce((a,b)=>a+b, 0);
      if (sum < total) {
        let rem = total - sum;
        while(rem-->0) feederConfig.push(1);
      } else if (sum > total) {
        let run=0;
        feederConfig = feederConfig.filter(n => {
          if (run+n <= total) { run+=n; return true; }
          if (run < total)     { feederConfig.push(total-run); run=total; return true; }
          return false;
        });
      }
    } else {
      while(remaining>0) {
        const cnt = Math.min(perFeeder||total, remaining);
        feederConfig.push(cnt);
        remaining -= cnt;
      }
    }

    // build parsedLayout…
    parsedLayout = [];
    let idx = 1;
    feederConfig.forEach((cnt,i) => {
      for(let j=0;j<cnt;j++){
        parsedLayout.push({
          feeder:   i+1,
          inverter: idx++,
          capacitor, voltage, impedance,
          hasLoad: lvLoad
        });
      }
    });

    drawVerticalRootLayout(feederConfig);
    fitToContainer();  // uses each padWidth/padHeight dynamically
  }

  function drawVerticalRootLayout(feederConfig) {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    updateTransform();

    busCoords = [];

    // layout constants
    const startX        = 100;
    const poiY          = 100;
    const gsuY          = poiY + 80;
    const mvY           = gsuY + 80;
    const feederSpacing = 180;
    const verticalSpacing = 100;
    const branchLength  = 50;
    const poiLen        = 200;
    const midX          = startX + (feederConfig.length * feederSpacing)/2;
    const poiStart      = midX - poiLen/2;
    const poiEnd        = midX + poiLen/2;
    poiOrigin = { x: midX, y: poiY };

    // helper to draw a line
    const drawLine = (x1,y1,x2,y2,clr='#000',w=2) => {
      ctx.save(); ctx.strokeStyle=clr; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    };

    // ── POI BUS ────────────────────────────────────────────────────
    drawLine(poiStart, poiY, poiEnd, poiY, '#000', 3);
    ctx.save(); ctx.fillStyle='#000'; ctx.font='12px Inter';
    ctx.fillText('POI BUS', poiStart, poiY-10);
    ctx.restore();
    busCoords.push({
      name: 'POI BUS',
      x: poiStart - poiOrigin.x + poiLen/2,
      y: 0,
      padWidth: poiLen/2,
      padHeight: 0
    });

    // ── Generator & T-Line ────────────────────────────────────────
    ctx.save();
      ctx.beginPath(); ctx.arc(midX, poiY-30, 10,0,2*Math.PI);
      ctx.stroke();
      ctx.fillText('Generator', midX-30, poiY-45);
    ctx.restore();
    drawLine(midX, poiY-20, midX, poiY);
    drawLine(midX, poiY, midX, gsuY);
    ctx.save(); ctx.fillText('T-Line', midX+10, (poiY+gsuY)/2); ctx.restore();

    // ── GSU HV BUS & Transformer ─────────────────────────────────
    drawLine(poiStart, gsuY, poiEnd, gsuY, '#0a66c2', 4);
    ctx.save(); ctx.fillText('GSU HV BUS', poiStart, gsuY-10); ctx.restore();
    const xfmrH = 40;
    busCoords.push({
      name: 'GSU HV BUS',
      x: poiStart - poiOrigin.x + poiLen/2,
      y: gsuY - poiOrigin.y,
      padWidth: poiLen/2,
      padHeight: xfmrH/2
    });

    // transformer body
    const xfmrTop = (gsuY + mvY)/2 - xfmrH/2;
    drawLine(midX, gsuY, midX, xfmrTop, '#2ecc71', 2);
    ctx.save(); ctx.fillStyle='#2ecc71';
      ctx.fillRect(midX-10, xfmrTop, 20, xfmrH);
    ctx.restore();
    drawLine(midX, xfmrTop+xfmrH, midX, mvY, '#2ecc71', 2);

    // ── SUB-MV BUS ────────────────────────────────────────────────
    const subMvLen = feederConfig.length * feederSpacing;
    drawLine(startX, mvY, startX+subMvLen, mvY, '#0a66c2', 4);
    ctx.save(); ctx.fillText('SUB-MV BUS', startX, mvY-10); ctx.restore();
    busCoords.push({
      name: 'SUB-MV BUS',
      x: startX - poiOrigin.x + subMvLen/2,
      y: mvY - poiOrigin.y,
      padWidth: subMvLen/2,
      padHeight: 0
    });

    // ── FEEDERS & INVERTERS ───────────────────────────────────────
    let invCtr = 0,
        feederX = startX + 40;

    feederConfig.forEach((cnt, idx) => {
      const bottomY = mvY + cnt * verticalSpacing;
      drawLine(feederX, mvY, feederX, bottomY, '#444', 2);

      for (let j = 0; j < cnt; j++) {
        const y = mvY + (j+1)*verticalSpacing;
        const invName = `INV${1001 + invCtr}`;

        // MV node & label
        drawLine(feederX, y, feederX + branchLength, y, '#0a66c2', 2);
        ctx.save(); ctx.fillStyle='red';
          ctx.beginPath(); ctx.arc(feederX, y, 4,0,2*Math.PI); ctx.fill();
          ctx.fillText(invName, feederX-55, y-10);
        ctx.restore();
        busCoords.push({
          name: invName,
          x: feederX - poiOrigin.x,
          y: y - poiOrigin.y,
          padWidth: branchLength + 12,   // picks up the inverter box too
          padHeight: verticalSpacing/2   // half‐spacing covers padmount + box
        });

        // padmount transformer
        ctx.save(); ctx.fillStyle='#2ecc71';
          ctx.fillRect(feederX + branchLength, y-10, 20, 20);
        ctx.restore();

        // LV node & inverter box
        const tX = feederX + branchLength + 10;
        const lvTop = y+10, lvBot = y+40, lvMid = (lvTop + lvBot)/2;
        drawLine(tX, lvTop, tX, lvBot, '#ff9900', 2);
        ctx.save(); ctx.fillStyle='blue';
          ctx.beginPath(); ctx.arc(tX, lvMid, 4,0,2*Math.PI); ctx.fill();
          ctx.fillText(`${invName}_LV`, tX+10, lvMid+10);
        ctx.restore();
        busCoords.push({
          name: `${invName}_LV`,
          x: tX - poiOrigin.x,
          y: lvMid - poiOrigin.y,
          padWidth: 12,    // inverter box half‐width
          padHeight: 12    // inverter box half‐height
        });

        // inverter box label
        ctx.save(); ctx.fillStyle='#ffcc00';
          ctx.fillRect(feederX+branchLength-2, lvBot, 24, 24);
        ctx.restore();
        ctx.save(); ctx.fillStyle='#000';
          ctx.fillText(`I${invCtr+1}`, feederX+branchLength-5, lvBot+35);
        ctx.restore();

        // optional LV load marker
        if (parsedLayout[invCtr].hasLoad) {
          ctx.save(); ctx.fillStyle='#ff4444';
            ctx.beginPath(); ctx.arc(tX+20, lvBot+12, 5,0,2*Math.PI); ctx.fill();
          ctx.restore();
        }

        invCtr++;
      }

      // feeder label (e.g. 11A, 11B…)
      const base = 11 + Math.floor(idx/2),
            suf  = (idx%2)?'B':'A',
            flbl = `${base}${suf}`;
      ctx.save(); ctx.fillText(flbl, feederX-10, bottomY+30); ctx.restore();

      feederX += feederSpacing;
    });

    // ── LEGEND ─────────────────────────────────────────────────────
    if (document.getElementById('showLegend').checked) {
      const lx = 1400, ly = 100;
      const items = [
        ['Red Dot','MV Bus Point'],
        ['Green Box','Transformer'],
        ['Blue Dot','LV Bus Point'],
        ['Yellow Box','Inverter'],
        ['Red Circle','LV Load']
      ];
      ctx.save(); ctx.fillText('Legend', lx, ly); ctx.restore();
      items.forEach(([shape,txt],i) => {
        const y = ly + 20 + i*20;
        const clr = shape.includes('Red')   ? 'red'
                  : shape.includes('Green') ? '#2ecc71'
                  : shape.includes('Blue')  ? 'blue'
                  :                         '#ffcc00';
        ctx.save(); ctx.fillStyle=clr;
        if (shape.includes('Dot')) ctx.beginPath(), ctx.arc(lx+10,y-4,5,0,2*Math.PI), ctx.fill();
        else                       ctx.fillRect(lx+3,y-10,14,14);
        ctx.restore();
        ctx.save(); ctx.fillStyle='#000';
        ctx.fillText(txt, lx+25, y);
        ctx.restore();
      });
    }

    // ── COORDINATES PANE ────────────────────────────────────────────
    const pane = document.getElementById('coordPane');
    if (document.getElementById('showCoords').checked) {
      pane.textContent = busCoords
        .map(b => `${b.name.padEnd(12)} (${b.x.toFixed(0).padStart(4)}, ${b.y.toFixed(0).padStart(4)})`)
        .join('\n');
    } else {
      pane.textContent = 'Bus coordinates will appear here when you check “Show Bus Coordinates” and hit Generate.';
    }
  }

  // ─── FUTURE-PROOF FITTOCONTAINER ────────────────────────────────
  // expands each point by its padWidth/padHeight before bounding
  function fitToContainer(margin = 20) {
    if (!busCoords.length) return;
    // compute absolute positions
    const allX = [], allY = [];
    busCoords.forEach(p => {
      const absX = p.x + poiOrigin.x,
            absY = p.y + poiOrigin.y;
      allX.push(absX - p.padWidth, absX + p.padWidth);
      allY.push(absY - p.padHeight, absY + p.padHeight);
    });

    const minX = Math.min(...allX),
          maxX = Math.max(...allX),
          minY = Math.min(...allY),
          maxY = Math.max(...allY);

    const contentW = (maxX - minX) + margin*2,
          contentH = (maxY - minY) + margin*2;
    const cw = container.clientWidth,
          ch = container.clientHeight;
    const newScale = Math.min(cw/contentW, ch/contentH);

    panX = (cw - contentW*newScale)/2 - (minX - margin)*newScale;
    panY = (ch - contentH*newScale)/2 - (minY - margin)*newScale;
    scale = newScale;

    updateTransform();
    slider.value = scale;
  }

  // ─── EXPORT HELPERS ─────────────────────────────────────────────
  window.exportSVG = () => {
    const a = document.createElement('a');
    a.download = 'schematic.svg';
    a.href = canvas.toDataURL('image/svg+xml');
    a.click();
  };
  window.exportPDF = () => {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation:'landscape',
      unit:'pt',
      format:[canvas.width, canvas.height]
    });
    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save('schematic.pdf');
  };
  window.exportDXF = () => alert('DXF export not implemented');
</script>
</body>
</html>
