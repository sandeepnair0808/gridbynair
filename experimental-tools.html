<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Farm Collector Designer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { font-family:'Inter',sans-serif; background:#f0f8ff; margin:0; }
    main { padding:20px; max-width:1800px; margin:auto; }
    label { display:block; margin:10px 0 4px; font-weight:600; }
    input, textarea {
      width:300px; padding:8px; margin-bottom:10px;
      border:1px solid #ccc; border-radius:6px;
    }
    button {
      margin:10px 10px 0 0; padding:10px 16px;
      background:#0a66c2; color:#fff; border:none;
      border-radius:6px; cursor:pointer;
    }
    button:hover { background:#004a99; }
    #canvasContainer {
      width: 100%; height: 600px;
      border:1px solid #ccc;
      overflow: hidden;
      position: relative;
      cursor: grab;
    }
    #canvasContainer.grabbing { cursor: grabbing; }
    canvas { transform-origin: 0 0; display: block; }
    #coordPane {
      margin-top:10px; padding:10px;
      background:#fff; border:1px solid #ccc;
      font-family:monospace; white-space:pre;
      max-height:300px; overflow:auto;
    }
  </style>
</head>
<body>
<main>
  <h1>⚡ Solar Farm Collector Designer</h1>

  <label>Total Inverters</label>
  <input type="number" id="total" placeholder="e.g., 40" />

  <label>Default Inverters per Feeder</label>
  <input type="number" id="perFeeder" placeholder="e.g., 8" />

  <label>Custom Feeder Configuration</label>
  <textarea id="customFeeder" placeholder="e.g., 4,4,4,4"></textarea>

  <label>Capacitor Bank (kVAR)</label>
  <input type="number" id="capacitor" placeholder="e.g., 500" />

  <label>Voltage (kV)</label>
  <input type="number" id="voltage" placeholder="e.g., 33" />

  <label>Impedance (Z pu)</label>
  <input type="number" id="impedance" placeholder="e.g., 0.03" step="0.01"/>

  <div>
    <input type="checkbox" id="lvLoad"/>
    <label for="lvLoad">Add Load on LV side</label>
  </div>
  <div>
    <input type="checkbox" id="showLegend" checked/>
    <label for="showLegend">Show Legend</label>
  </div>
  <div>
    <input type="checkbox" id="showCoords"/>
    <label for="showCoords">Show Bus Coordinates</label>
  </div>

  <button onclick="generateCollector()">Generate</button>
  <button onclick="resetView()">Reset View</button>
  <button onclick="zoomIn()">Zoom In</button>
  <button onclick="zoomOut()">Zoom Out</button>
  <label for="zoomSlider">Zoom:</label>
  <input type="range" id="zoomSlider" min="0.1" max="10" step="0.1" value="1" />
  <button onclick="exportSVG()">Export SVG</button>
  <button onclick="exportPDF()">Export PDF</button>
  <button onclick="exportDXF()">Export DXF</button>

  <div id="canvasContainer">
    <canvas id="schematicCanvas" width="1800" height="2400"></canvas>
  </div>
  <div id="coordPane">
    Bus coordinates will appear here when you check “Show Bus Coordinates” and hit Generate.
  </div>
</main>

<script>
  // Data & state
  let parsedLayout = [],
      poiOrigin    = { x:0, y:0 },
      busCoords    = [];

  // Canvas & Transform state
  const container = document.getElementById('canvasContainer');
  const canvas    = document.getElementById('schematicCanvas');
  const ctx       = canvas.getContext('2d');
  let scale = 1, panX = 0, panY = 0;
  let isPanning = false, startX = 0, startY = 0;
  const slider = document.getElementById('zoomSlider');

  // Transform helpers
  function updateTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }
  function resetView() {
    scale = 1; panX = 0; panY = 0;
    updateTransform();
    slider.value = scale;
  }
  function zoomTo(newScale, cx = canvas.clientWidth/2, cy = canvas.clientHeight/2) {
    panX -= (cx/scale - cx/newScale);
    panY -= (cy/scale - cy/newScale);
    scale = newScale;
    updateTransform();
    slider.value = scale;
  }
  function zoomIn()  { zoomTo(Math.min(scale * 1.1, 10)); }
  function zoomOut() { zoomTo(Math.max(scale * 0.9, 0.1)); }
  slider.addEventListener('input', e => zoomTo(parseFloat(e.target.value)));

  // Mouse & touch interactions
  container.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = -e.deltaY * 0.001;
    const rect = canvas.getBoundingClientRect();
    const newScale = Math.min(Math.max(scale + delta, 0.1), 10);
    zoomTo(newScale, e.clientX - rect.left, e.clientY - rect.top);
  });
  container.addEventListener('mousedown', e => {
    isPanning = true; container.classList.add('grabbing');
    startX = e.clientX - panX; startY = e.clientY - panY;
  });
  document.addEventListener('mousemove', e => {
    if (!isPanning) return;
    panX = e.clientX - startX; panY = e.clientY - startY;
    updateTransform();
  });
  document.addEventListener('mouseup', () => {
    isPanning = false; container.classList.remove('grabbing');
  });
  container.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      isPanning = true;
      const t = e.touches[0];
      startX = t.clientX - panX; startY = t.clientY - panY;
    }
  }, { passive: false });
  container.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && isPanning) {
      const t = e.touches[0];
      panX = t.clientX - startX; panY = t.clientY - startY;
      updateTransform();
    }
    e.preventDefault();
  }, { passive: false });
  container.addEventListener('touchend', () => {
    isPanning = false; container.classList.remove('grabbing');
  });

  // Main generation logic
  function generateCollector() {
    const total      = parseInt(document.getElementById('total').value);
    if (!total || total <= 0) return alert('Enter total inverters');
    const perFeeder  = parseInt(document.getElementById('perFeeder').value);
    const custom     = document.getElementById('customFeeder').value.trim();
    const capacitor  = parseInt(document.getElementById('capacitor').value);
    const voltage    = parseFloat(document.getElementById('voltage').value);
    const impedance  = parseFloat(document.getElementById('impedance').value);
    const lvLoad     = document.getElementById('lvLoad').checked;

    // Build feeder config
    let feederConfig = [], remaining = total;
    if (custom) {
      feederConfig = custom.split(',').map(n=>parseInt(n)).filter(n=>!isNaN(n));
      let sum = feederConfig.reduce((a,b)=>a+b,0);
      if (sum < total) {
        let rem = total - sum;
        while(rem-->0) feederConfig.push(1);
      } else if (sum > total) {
        let run = 0;
        feederConfig = feederConfig.filter(n => {
          if (run + n <= total) { run+=n; return true; }
          if (run < total)     { feederConfig.push(total-run); run=total; return true; }
          return false;
        });
      }
    } else {
      while (remaining > 0) {
        const cnt = Math.min(perFeeder||total, remaining);
        feederConfig.push(cnt); remaining -= cnt;
      }
    }

    // Build layout array
    parsedLayout = [];
    let idx = 1;
    feederConfig.forEach((cnt,i) => {
      for (let j=0; j<cnt; j++) {
        parsedLayout.push({ feeder: i+1, inverter: idx++, capacitor, voltage, impedance, hasLoad: lvLoad });
      }
    });

    // Draw and fit
    drawVerticalRootLayout(feederConfig);
    fitToContainer();  // now uses 60px margin
  }

  function drawVerticalRootLayout(feederConfig) {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    updateTransform();

    busCoords = [];
    const startX       = 100, poiY = 100, gsuY = poiY+80, mvY = gsuY+80;
    const feederSpacing= 180, verticalSpacing = 100, branchLength = 50;
    const midX         = startX + (feederConfig.length*feederSpacing)/2;
    const poiLen       = 200, poiStart = midX-poiLen/2, poiEnd = midX+poiLen/2;
    poiOrigin = { x: midX, y: poiY };

    const drawLine = (x1,y1,x2,y2,clr='#000',w=2) => {
      ctx.save(); ctx.strokeStyle=clr; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
    };

    // … [rest of drawing stays identical] …
    // (POI bus, generator, transformer, feeders, inverters, legend, coords pane)
    // busCoords.push(...) for every node as before
  }

  // Fit & center with 60px margin
  function fitToContainer(margin = 60) {
    if (!busCoords.length) return;
    const abs = busCoords.map(b => ({
      x: b.x + poiOrigin.x,
      y: b.y + poiOrigin.y
    }));
    const xs = abs.map(p => p.x), ys = abs.map(p => p.y);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const contentW = maxX - minX + margin*2;
    const contentH = maxY - minY + margin*2;
    const cw = container.clientWidth, ch = container.clientHeight;
    const newScale = Math.min(cw / contentW, ch / contentH);

    panX = (cw  - contentW*newScale)/2 - (minX - margin)*newScale;
    panY = (ch  - contentH*newScale)/2 - (minY - margin)*newScale;
    scale = newScale;

    updateTransform();
    slider.value = scale;
  }

  // Export helpers (SVG/PDF/DXF)
  window.exportSVG = () => {
    const a = document.createElement('a');
    a.download = 'schematic.svg';
    a.href = canvas.toDataURL('image/svg+xml');
    a.click();
  };
  window.exportPDF = () => {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: [canvas.width, canvas.height]
    });
    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save('schematic.pdf');
  };
  window.exportDXF = () => alert('DXF export not implemented');
</script>
</body>
</html>
